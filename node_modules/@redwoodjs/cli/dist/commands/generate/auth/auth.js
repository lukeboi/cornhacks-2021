"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.handler = exports.builder = exports.description = exports.command = exports.graphFunctionDoesExist = exports.webIndexDoesExist = exports.apiSrcDoesExist = exports.isProviderSupported = exports.addApiConfig = exports.addConfigToIndex = exports.files = void 0;

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/index-of"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/promise"));

var _interopRequireWildcard2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/interopRequireWildcard"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _execa = _interopRequireDefault(require("execa"));

var _listr = _interopRequireDefault(require("listr"));

var _terminalLink = _interopRequireDefault(require("terminal-link"));

var _internal = require("@redwoodjs/internal");

var _lib = require("../../../lib");

var _colors = _interopRequireDefault(require("../../../lib/colors"));

var _context, _context2, _context3;

const API_GRAPHQL_PATH = (0, _internal.resolveFile)(_path.default.join((0, _lib.getPaths)().api.functions, 'graphql'));
const AUTH_PROVIDER_IMPORT = `import { AuthProvider } from '@redwoodjs/auth'`;

const API_SRC_PATH = _path.default.join((0, _lib.getPaths)().api.src);

const TEMPLATES = (0, _reduce.default)(_context = _fs.default.readdirSync(_path.default.resolve(__dirname, 'templates'))).call(_context, (templates, file) => {
  if (file === 'auth.js.template') {
    return { ...templates,
      base: _path.default.resolve(__dirname, 'templates', file)
    };
  } else {
    const provider = file.replace('.auth.js.template', '');
    return { ...templates,
      [provider]: _path.default.resolve(__dirname, 'templates', file)
    };
  }
}, {});

const OUTPUT_PATH = _path.default.join((0, _lib.getPaths)().api.lib, 'auth.js');

const WEB_SRC_INDEX_PATH = _path.default.join((0, _lib.getPaths)().web.src, 'index.js');

const SUPPORTED_PROVIDERS = (0, _filter.default)(_context2 = (0, _map.default)(_context3 = _fs.default.readdirSync(_path.default.resolve(__dirname, 'providers'))).call(_context3, file => _path.default.basename(file, '.js'))).call(_context2, file => file !== 'README.md'); // returns the content of index.js with import statements added

const addWebImports = (content, imports) => {
  return `${AUTH_PROVIDER_IMPORT}\n` + imports.join('\n') + '\n' + content;
}; // returns the content of index.js with init lines added


const addWebInit = (content, init) => {
  return content.replace(/ReactDOM.render/, `${init}\n\nReactDOM.render`);
}; // returns the content of index.js with <AuthProvider> added


const addWebRender = (content, authProvider) => {
  var _context4;

  const [_, indent, redwoodProvider] = content.match(/(\s+)(<RedwoodProvider>.*<\/RedwoodProvider>)/s);
  const redwoodProviderLines = (0, _map.default)(_context4 = redwoodProvider.split('\n')).call(_context4, line => {
    return '  ' + line;
  });
  const renderContent = indent + `<AuthProvider client={${authProvider.client}} type="${authProvider.type}">` + indent + redwoodProviderLines.join('\n') + indent + `</AuthProvider>`;
  return content.replace(/\s+<RedwoodProvider>.*<\/RedwoodProvider>/s, renderContent);
}; // returns the content of index.js with <AuthProvider> updated


const updateWebRender = (content, authProvider) => {
  const renderContent = `<AuthProvider client={${authProvider.client}} type="${authProvider.type}">`;
  return content.replace(/<AuthProvider client={.*} type=".*">/s, renderContent);
}; // returns the content of index.js without the old auth import


const removeOldWebImports = (content, imports) => {
  return content.replace(`${AUTH_PROVIDER_IMPORT}\n` + imports.join('\n'), '');
}; // returns the content of index.js without the old auth init


const removeOldWebInit = (content, init) => {
  return content.replace(init, '');
}; // returns content with old auth provider removes


const removeOldAuthProvider = async content => {
  // get the current auth provider
  const [_, currentAuthProvider] = content.match(/<AuthProvider client={.*} type="(.*)">/s);
  let oldAuthProvider;

  try {
    oldAuthProvider = await _promise.default.resolve(`./providers/${currentAuthProvider}`).then(s => (0, _interopRequireWildcard2.default)(require(s)));
  } catch (e) {
    throw new Error('Could not replace existing auth provider init');
  }

  content = removeOldWebImports(content, oldAuthProvider.config.imports);
  content = removeOldWebInit(content, oldAuthProvider.config.init);
  return content;
}; // check to make sure AuthProvider doesn't exist


const checkAuthProviderExists = () => {
  const content = _fs.default.readFileSync(WEB_SRC_INDEX_PATH).toString();

  if ((0, _includes.default)(content).call(content, AUTH_PROVIDER_IMPORT)) {
    throw new Error('Existing auth provider found.\nUse --force to override existing provider.');
  }
}; // the files to create to support auth


const files = provider => {
  var _TEMPLATES$provider;

  const template = (_TEMPLATES$provider = TEMPLATES[provider]) !== null && _TEMPLATES$provider !== void 0 ? _TEMPLATES$provider : TEMPLATES.base;
  return {
    [OUTPUT_PATH]: _fs.default.readFileSync(template).toString()
  };
}; // actually inserts the required config lines into index.js


exports.files = files;

const addConfigToIndex = async (config, force) => {
  let content = _fs.default.readFileSync(WEB_SRC_INDEX_PATH).toString(); // update existing AuthProvider if --force else add new AuthProvider


  if ((0, _includes.default)(content).call(content, AUTH_PROVIDER_IMPORT) && force) {
    content = await removeOldAuthProvider(content);
    content = updateWebRender(content, config.authProvider);
  } else {
    content = addWebRender(content, config.authProvider);
  }

  content = addWebImports(content, config.imports);
  content = addWebInit(content, config.init);

  _fs.default.writeFileSync(WEB_SRC_INDEX_PATH, content);
};

exports.addConfigToIndex = addConfigToIndex;

const addApiConfig = () => {
  let content = _fs.default.readFileSync(API_GRAPHQL_PATH).toString(); // default to an array to avoid destructure errors


  const [_, hasAuthImport] = content.match(/(import {.*} from 'src\/lib\/auth.*')/s) || [];

  if (!hasAuthImport) {
    // add import statement
    content = content.replace(/^(.*services.*)$/m, `$1\n\nimport { getCurrentUser } from 'src/lib/auth'`); // add object to handler

    content = content.replace(/^(\s*)(schema: makeMergedSchema)(.*)$/m, `$1getCurrentUser,\n$1$2$3`);

    _fs.default.writeFileSync(API_GRAPHQL_PATH, content);
  }
};

exports.addApiConfig = addApiConfig;

const isProviderSupported = provider => {
  return (0, _indexOf.default)(SUPPORTED_PROVIDERS).call(SUPPORTED_PROVIDERS, provider) !== -1;
};

exports.isProviderSupported = isProviderSupported;

const apiSrcDoesExist = () => {
  return _fs.default.existsSync(API_SRC_PATH);
};

exports.apiSrcDoesExist = apiSrcDoesExist;

const webIndexDoesExist = () => {
  return _fs.default.existsSync(WEB_SRC_INDEX_PATH);
};

exports.webIndexDoesExist = webIndexDoesExist;

const graphFunctionDoesExist = () => {
  return _fs.default.existsSync(API_GRAPHQL_PATH);
};

exports.graphFunctionDoesExist = graphFunctionDoesExist;
const command = 'auth <provider>';
exports.command = command;
const description = 'Generate an auth configuration';
exports.description = description;

const builder = yargs => {
  yargs.positional('provider', {
    choices: SUPPORTED_PROVIDERS,
    description: 'Auth provider to configure',
    type: 'string'
  }).option('force', {
    alias: 'f',
    default: false,
    description: 'Overwrite existing configuration',
    type: 'boolean'
  }).epilogue(`Also see the ${(0, _terminalLink.default)('Redwood CLI Reference', 'https://redwoodjs.com/reference/command-line-interface#generate-auth')}`);
};

exports.builder = builder;

const handler = async ({
  provider,
  force
}) => {
  var _context5;

  const providerData = await _promise.default.resolve(`./providers/${provider}`).then(s => (0, _interopRequireWildcard2.default)(require(s)));
  const tasks = new _listr.default((0, _filter.default)(_context5 = [{
    title: 'Generating auth lib...',
    task: (_ctx, task) => {
      if (apiSrcDoesExist()) {
        return (0, _lib.writeFilesTask)(files(provider), {
          overwriteExisting: force
        });
      } else {
        task.skip('api/src not found, skipping');
      }
    }
  }, {
    title: 'Adding auth config to web...',
    task: (_ctx, task) => {
      if (webIndexDoesExist()) {
        addConfigToIndex(providerData.config, force);
      } else {
        task.skip('web/src/index.js not found, skipping');
      }
    }
  }, {
    title: 'Adding auth config to GraphQL API...',
    task: (_ctx, task) => {
      if (graphFunctionDoesExist()) {
        addApiConfig();
      } else {
        task.skip('GraphQL function not found, skipping');
      }
    }
  }, {
    title: 'Adding required web packages...',
    task: async () => {
      if (!isProviderSupported(provider)) {
        throw new Error(`Unknown auth provider '${provider}'`);
      }

      await (0, _execa.default)('yarn', ['workspace', 'web', 'add', ...providerData.webPackages, '@redwoodjs/auth']);
    }
  }, providerData.apiPackages.length > 0 && {
    title: 'Adding required api packages...',
    task: async () => {
      if (!isProviderSupported(provider)) {
        throw new Error(`Unknown auth provider '${provider}'`);
      }

      await (0, _execa.default)('yarn', ['workspace', 'api', 'add', ...providerData.apiPackages]);
    }
  }, {
    title: 'Installing packages...',
    task: async () => {
      await (0, _execa.default)('yarn', ['install']);
    }
  }, {
    title: 'One more thing...',
    task: (_ctx, task) => {
      task.title = `One more thing...\n\n   ${providerData.notes.join('\n   ')}\n`;
    }
  }]).call(_context5, Boolean), {
    collapse: false
  });

  try {
    // Don't throw existing provider error when --force exists
    if (!force) {
      checkAuthProviderExists();
    }

    await tasks.run();
  } catch (e) {
    console.log(_colors.default.error(e.message));
  }
};

exports.handler = handler;
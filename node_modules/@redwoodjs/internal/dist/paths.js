"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.ensurePosixPath = exports.processPagesDir = exports.getPaths = exports.resolveFile = exports.getBaseDirFromFile = exports.getBaseDir = exports.getConfigPath = void 0;

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _findupSync = _interopRequireDefault(require("findup-sync"));

var _config = require("./config");

const CONFIG_FILE_NAME = 'redwood.toml';
const PATH_API_DIR_FUNCTIONS = 'api/src/functions';
const PATH_API_DIR_GRAPHQL = 'api/src/graphql';
const PATH_API_DIR_CONFIG = 'api/src/config';
const PATH_API_DIR_LIB = 'api/src/lib';
const PATH_API_DIR_SERVICES = 'api/src/services';
const PATH_API_DIR_SRC = 'api/src';
const PATH_WEB_ROUTES = 'web/src/Routes'; // .js|.tsx

const PATH_WEB_DIR_LAYOUTS = 'web/src/layouts/';
const PATH_WEB_DIR_PAGES = 'web/src/pages/';
const PATH_WEB_DIR_COMPONENTS = 'web/src/components';
const PATH_WEB_DIR_SRC = 'web/src';
const PATH_WEB_DIR_SRC_INDEX = 'web/src/index'; // .js|.tsx

const PATH_WEB_DIR_CONFIG = 'web/config';
const PATH_WEB_DIR_CONFIG_WEBPACK = 'web/config/webpack.config.js';
const PATH_WEB_DIR_CONFIG_POSTCSS = 'web/config/postcss.config.js';
/**
 * Search the parent directories for the Redwood configuration file.
 */

const getConfigPath = (cwd = process.cwd()) => {
  const configPath = (0, _findupSync.default)(CONFIG_FILE_NAME, {
    cwd
  });

  if (!configPath) {
    throw new Error(`Could not find a "${CONFIG_FILE_NAME}" file, are you sure you're in a Redwood project?`);
  }

  return configPath;
};
/**
 * The Redwood config file is used as an anchor for the base directory of a project.
 */


exports.getConfigPath = getConfigPath;

const getBaseDir = (configPath = getConfigPath()) => {
  return _path.default.dirname(configPath);
};

exports.getBaseDir = getBaseDir;

const getBaseDirFromFile = file => {
  return getBaseDir(getConfigPath(_path.default.dirname(file)));
};
/**
 * Use this to resolve files when the path to the file is known, but the extension
 * is not.
 */


exports.getBaseDirFromFile = getBaseDirFromFile;

const resolveFile = (filePath, extensions = ['.js', '.tsx', '.ts', '.jsx']) => {
  for (const extension of extensions) {
    const p = `${filePath}${extension}`;

    if (_fs.default.existsSync(p)) {
      return p;
    }
  }

  return null;
};
/**
 * Path constants that are relevant to a Redwood project.
 */


exports.resolveFile = resolveFile;

const getPaths = (BASE_DIR = getBaseDir()) => {
  const routes = resolveFile(_path.default.join(BASE_DIR, PATH_WEB_ROUTES));
  const {
    schemaPath
  } = (0, _config.getConfig)(getConfigPath(BASE_DIR)).api;

  const schemaDir = _path.default.dirname(schemaPath); // We store our test database over here:


  const cache = _path.default.join(BASE_DIR, '.redwood');

  const types = _path.default.join(BASE_DIR, '.redwood', 'types');

  _fs.default.mkdirSync(cache, {
    recursive: true
  });

  _fs.default.mkdirSync(types, {
    recursive: true
  });

  return {
    base: BASE_DIR,
    cache,
    types,
    api: {
      base: _path.default.join(BASE_DIR, 'api'),
      dataMigrations: _path.default.join(BASE_DIR, schemaDir, 'dataMigrations'),
      db: _path.default.join(BASE_DIR, schemaDir),
      dbSchema: _path.default.join(BASE_DIR, schemaPath),
      functions: _path.default.join(BASE_DIR, PATH_API_DIR_FUNCTIONS),
      graphql: _path.default.join(BASE_DIR, PATH_API_DIR_GRAPHQL),
      lib: _path.default.join(BASE_DIR, PATH_API_DIR_LIB),
      config: _path.default.join(BASE_DIR, PATH_API_DIR_CONFIG),
      services: _path.default.join(BASE_DIR, PATH_API_DIR_SERVICES),
      src: _path.default.join(BASE_DIR, PATH_API_DIR_SRC)
    },
    web: {
      routes,
      base: _path.default.join(BASE_DIR, 'web'),
      pages: _path.default.join(BASE_DIR, PATH_WEB_DIR_PAGES),
      components: _path.default.join(BASE_DIR, PATH_WEB_DIR_COMPONENTS),
      layouts: _path.default.join(BASE_DIR, PATH_WEB_DIR_LAYOUTS),
      src: _path.default.join(BASE_DIR, PATH_WEB_DIR_SRC),
      index: _path.default.join(BASE_DIR, PATH_WEB_DIR_SRC_INDEX),
      config: _path.default.join(BASE_DIR, PATH_WEB_DIR_CONFIG),
      webpack: _path.default.join(BASE_DIR, PATH_WEB_DIR_CONFIG_WEBPACK),
      postcss: _path.default.join(BASE_DIR, PATH_WEB_DIR_CONFIG_POSTCSS)
    }
  };
};
/**
 * Recursively process the pages directory and return information useful for
 * automated imports.
 */


exports.getPaths = getPaths;

const processPagesDir = (webPagesDir = getPaths().web.pages, prefix = []) => {
  const deps = [];

  const entries = _fs.default.readdirSync(webPagesDir, {
    withFileTypes: true
  }); // Iterate over a dir's entries, recursing as necessary into
  // subdirectories.


  (0, _forEach.default)(entries).call(entries, entry => {
    if (entry.isDirectory()) {
      try {
        // Actual page js or tsx files reside in a directory of the same
        // name (supported by: directory-named-webpack-plugin), so let's
        // construct the filename of the actual Page file.
        // `require.resolve` will throw if a module cannot be found.
        const importPath = _path.default.join(webPagesDir, entry.name, entry.name);

        require.resolve(importPath); // If the Page exists, then construct the dependency object and push it
        // onto the deps array.


        const basename = _path.default.posix.basename(entry.name);

        const importName = prefix.join() + basename; // `src/pages/<PageName>`

        const importFile = ['src', 'pages', ...prefix, basename].join('/');
        deps.push({
          importName,
          importPath,
          const: importName,
          path: _path.default.join(webPagesDir, entry.name),
          importStatement: `const ${importName.split(',').join('')} = { name: '${importName.split(',').join('')}', loader: () => import('${importFile}') }`
        });
      } catch (e) {
        // If the Page doesn't exist then we are in a directory of Page
        // directories, so let's recurse into it and do the whole thing over
        // again.
        const newPrefix = [...prefix, entry.name];
        deps.push(...processPagesDir(_path.default.join(webPagesDir, entry.name), newPrefix));
      }
    }
  });
  return deps;
};
/**
 * Converts Windows-style paths to Posix-style
 * C:\Users\Bob\dev\Redwood -> /c/Users/Bob/dev/Redwood
 *
 * The conversion only happens on Windows systems, and only for paths that are
 * not already Posix-style
 *
 * @param path Filesystem path
 */


exports.processPagesDir = processPagesDir;

const ensurePosixPath = path => {
  let posixPath = path;

  if (process.platform === 'win32') {
    if (/^[A-Z]:\\/.test(path)) {
      const drive = path[0].toLowerCase();
      posixPath = `/${drive}/${path.substring(3)}`;
    }

    posixPath = posixPath.replace(/\\/g, '/');
  }

  return posixPath;
};

exports.ensurePosixPath = ensurePosixPath;